#!/bin/bash

set -euo pipefail

# Configuration
FIREWALL_DIR="/etc/firewall-manager"
RULES_DIR="/etc/firewall-manager/rules.d"
BASE_RULES="$FIREWALL_DIR/base.rules"
LOG_FILE="/var/log/firewall-manager.log"
FALLBACK_CHAIN="fwm-fallback"

# Logging function
log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') $*" | tee -a "$LOG_FILE"
}

# Error handling
error_exit() {
    log "ERROR: $1"
    exit 1
}

# Check if running as root
check_root() {
    if [[ $EUID -ne 0 ]]; then
        error_exit "This script must be run as root"
    fi
}

# Validate iptables availability
check_iptables() {
    if ! command -v iptables >/dev/null 2>&1; then
        error_exit "iptables command not found"
    fi
    if ! command -v iptables-restore >/dev/null 2>&1; then
        error_exit "iptables-restore command not found"
    fi
}

# Create necessary directories
setup_directories() {
    mkdir -p "$FIREWALL_DIR" "$RULES_DIR"
    chmod 700 "$FIREWALL_DIR" "$RULES_DIR"
}

# Apply base rules
apply_base_rules() {
    if [[ ! -f "$BASE_RULES" ]]; then
        error_exit "Base rules file not found: $BASE_RULES"
    fi

    log "Applying base firewall rules..."
    if ! iptables-restore < "$BASE_RULES"; then
        error_exit "Failed to apply base rules"
    fi
    log "Base rules applied successfully"
}

# Apply modular rules in order
apply_modular_rules() {
    log "Applying modular rules from $RULES_DIR..."

    # Find all .rules files and sort them numerically
    local rule_files
    mapfile -t rule_files < <(find "$RULES_DIR" -name "*.rules" -type f | sort -V)

    if [[ ${#rule_files[@]} -eq 0 ]]; then
        log "No modular rule files found in $RULES_DIR"
        return 0
    fi

    for rule_file in "${rule_files[@]}"; do
        local filename=$(basename "$rule_file")
        log "Applying rules from $filename..."

        # Validate file before applying
        if ! iptables-restore --test < "$rule_file" >/dev/null 2>&1; then
            log "WARNING: Skipping invalid rule file: $filename"
            continue
        fi

        # Apply rules (append mode)
        if ! iptables-restore --noflush < "$rule_file"; then
            log "WARNING: Failed to apply rules from $filename"
            continue
        fi

        log "Successfully applied rules from $filename"
    done
}

# Remove fallback chain (make firewall restrictive)
remove_fallback() {
    log "Removing fallback chain to enable restrictive mode..."

    # Check if fallback chain exists
    if ! iptables -L "$FALLBACK_CHAIN" >/dev/null 2>&1; then
        log "Fallback chain '$FALLBACK_CHAIN' not found, nothing to remove"
        return 0
    fi

    # Remove references to fallback chain from INPUT
    iptables -D INPUT -j "$FALLBACK_CHAIN" 2>/dev/null || true

    # Flush and delete the fallback chain
    iptables -F "$FALLBACK_CHAIN" 2>/dev/null || true
    iptables -X "$FALLBACK_CHAIN" 2>/dev/null || true

    log "Fallback chain removed - firewall is now in restrictive mode"
}

# Show current firewall status
show_status() {
    echo "=== Firewall Manager Status ==="
    echo
    echo "Filter table:"
    iptables -t filter -L -n -v
    echo
    echo "Available rule files:"
    find "$RULES_DIR" -name "*.rules" -type f | sort -V | while read -r file; do
        echo "  $(basename "$file")"
    done
    echo
    if iptables -L "$FALLBACK_CHAIN" >/dev/null 2>&1; then
        echo "FALLBACK MODE: Firewall is running in permissive mode"
        echo "   Run 'fwmctl harden' to enable restrictive mode"
    else
        echo "RESTRICTIVE MODE: Firewall is hardened"
    fi
}

# Backup current rules
backup_rules() {
    local backup_file="/var/fwm-backups/firewall-manager-$(date +%Y%m%d-%H%M%S).rules"
    mkdir -p /var/fwm-backups
    iptables-save > "$backup_file"
    log "Current rules backed up to $backup_file"
}

# Restore from backup
restore_backup() {
    local backup_file="$1"
    if [[ ! -f "$backup_file" ]]; then
        error_exit "Backup file not found: $backup_file"
    fi

    log "Restoring firewall rules from $backup_file..."
    if ! iptables-restore < "$backup_file"; then
        error_exit "Failed to restore from backup"
    fi
    log "Rules restored successfully"
}

# Cleanup/reset firewall to permissive state
cleanup_firewall() {
    log "Cleaning up firewall - resetting to permissive state..."

    # Backup current rules before cleanup
    backup_rules

    # Set default policies to ACCEPT for all chains in filter table
    log "Setting default policies to ACCEPT..."
    iptables -P INPUT ACCEPT 2>/dev/null || true
    iptables -P FORWARD ACCEPT 2>/dev/null || true
    iptables -P OUTPUT ACCEPT 2>/dev/null || true

    # Flush all rules from all tables
    log "Flushing all iptables rules..."

    # Filter table
    iptables -t filter -F 2>/dev/null || true
    iptables -t filter -X 2>/dev/null || true

    # NAT table (if it exists)
    iptables -t nat -F 2>/dev/null || true
    iptables -t nat -X 2>/dev/null || true
    iptables -t nat -P PREROUTING ACCEPT 2>/dev/null || true
    iptables -t nat -P INPUT ACCEPT 2>/dev/null || true
    iptables -t nat -P OUTPUT ACCEPT 2>/dev/null || true
    iptables -t nat -P POSTROUTING ACCEPT 2>/dev/null || true

    # Mangle table
    iptables -t mangle -F 2>/dev/null || true
    iptables -t mangle -X 2>/dev/null || true
    iptables -t mangle -P PREROUTING ACCEPT 2>/dev/null || true
    iptables -t mangle -P INPUT ACCEPT 2>/dev/null || true
    iptables -t mangle -P FORWARD ACCEPT 2>/dev/null || true
    iptables -t mangle -P OUTPUT ACCEPT 2>/dev/null || true
    iptables -t mangle -P POSTROUTING ACCEPT 2>/dev/null || true

    # Raw table
    iptables -t raw -F 2>/dev/null || true
    iptables -t raw -X 2>/dev/null || true
    iptables -t raw -P PREROUTING ACCEPT 2>/dev/null || true
    iptables -t raw -P OUTPUT ACCEPT 2>/dev/null || true

    # Security table (if it exists)
    iptables -t security -F 2>/dev/null || true
    iptables -t security -X 2>/dev/null || true
    iptables -t security -P INPUT ACCEPT 2>/dev/null || true
    iptables -t security -P FORWARD ACCEPT 2>/dev/null || true
    iptables -t security -P OUTPUT ACCEPT 2>/dev/null || true

    log "Firewall cleanup completed - all rules flushed, policies set to ACCEPT"
    log "WARNING: Firewall is now in completely permissive mode!"
    log "Use 'fwmctl start' or 'fwmctl apply' to reapply security rules"
}

# Comprehensive debug and diagnostics
debug_firewall() {
    echo "=== FIREWALL DEBUG AND DIAGNOSTICS ==="
    echo "Timestamp: $(date)"
    echo

    # Basic system info
    echo "=== SYSTEM INFO ==="
    echo "Kernel: $(uname -r)"
    echo "OS: $(cat /etc/os-release | grep PRETTY_NAME | cut -d'"' -f2 2>/dev/null || echo 'Unknown')"
    echo "Current user: $(whoami)"
    echo "SSH connection: ${SSH_CLIENT:-'Not SSH'}"
    echo

    # Network interfaces
    echo "=== NETWORK INTERFACES ==="
    ip -4 addr show | grep -E '^[0-9]+:|inet ' | sed 's/^[[:space:]]*/  /'
    echo
    echo "Docker interfaces:"
    ip link show | grep docker || echo "  No Docker interfaces found"
    echo

    # Rule file validation
    echo "=== RULE FILE VALIDATION ==="
    echo "Base rules file: $BASE_RULES"
    if [[ -f "$BASE_RULES" ]]; then
        echo "  File exists: YES"
        if iptables-restore --test < "$BASE_RULES" >/dev/null 2>&1; then
            echo "  Syntax valid: YES"
        else
            echo "  Syntax valid: NO"
            echo "  Error details:"
            iptables-restore --test < "$BASE_RULES" 2>&1 | sed 's/^/    /'
        fi
    else
        echo "  File exists: NO"
    fi
    echo

    echo "Modular rules validation:"
    find "$RULES_DIR" -name "*.rules" -type f | sort -V | while read -r rule_file; do
        filename=$(basename "$rule_file")
        echo "  $filename:"
        if iptables-restore --test < "$rule_file" >/dev/null 2>&1; then
            echo "    Syntax: VALID"
        else
            echo "    Syntax: INVALID"
            echo "    Error:"
            iptables-restore --test < "$rule_file" 2>&1 | sed 's/^/      /'
        fi
    done
    echo

    # Current iptables state
    echo "=== CURRENT IPTABLES STATE ==="
    echo "Default policies:"
    iptables -L | grep '^Chain' | grep 'policy'
    echo
    echo "Rule counts by table:"
    echo "  Filter: $(iptables -t filter -S | wc -l) rules"
    echo "  Mangle: $(iptables -t mangle -S | wc -l) rules"
    echo "  Raw: $(iptables -t raw -S | wc -l) rules"
    echo "  NAT: $(iptables -t nat -S 2>/dev/null | wc -l || echo 0) rules"
    echo

    # SYNPROXY diagnostics
    echo "=== SYNPROXY DIAGNOSTICS ==="

    # Check if SYNPROXY module is loaded
    if [[ -f /proc/net/stat/synproxy ]]; then
        echo "SYNPROXY module: LOADED"
        echo "SYNPROXY statistics:"
        cat /proc/net/stat/synproxy | sed 's/^/  /'
        echo

        # Check for SYNPROXY rules
        echo "SYNPROXY rules in iptables:"
        synproxy_rules=$(iptables -L INPUT -n -v | grep SYNPROXY || true)
        if [[ -n "$synproxy_rules" ]]; then
            echo "$synproxy_rules" | sed 's/^/  /'
        else
            echo "  No SYNPROXY rules found"
        fi
        echo

        # Check required sysctl settings
        echo "SYNPROXY kernel settings:"
        echo "  nf_conntrack_tcp_loose: $(sysctl -n net/netfilter/nf_conntrack_tcp_loose 2>/dev/null || echo 'NOT SET')"
        echo "  tcp_timestamps: $(sysctl -n net/ipv4/tcp_timestamps 2>/dev/null || echo 'NOT SET')"
        echo "  nf_conntrack_max: $(sysctl -n net/netfilter/nf_conntrack_max 2>/dev/null || echo 'NOT SET')"

        if [[ -f /sys/module/nf_conntrack/parameters/hashsize ]]; then
            echo "  conntrack_hashsize: $(cat /sys/module/nf_conntrack/parameters/hashsize)"
        else
            echo "  conntrack_hashsize: NOT ACCESSIBLE"
        fi
        echo

        # Check for specific issues
        tcp_loose=$(sysctl -n net/netfilter/nf_conntrack_tcp_loose 2>/dev/null || echo "1")
        if [[ "$tcp_loose" != "0" ]]; then
            echo "ISSUE: nf_conntrack_tcp_loose should be 0 for SYNPROXY"
            echo "  Fix: sysctl -w net/netfilter/nf_conntrack_tcp_loose=0"
            echo
        fi

        timestamps=$(sysctl -n net/ipv4/tcp_timestamps 2>/dev/null || echo "0")
        if [[ "$timestamps" != "1" ]]; then
            echo "ISSUE: tcp_timestamps should be 1 for SYNPROXY"
            echo "  Fix: sysctl -w net/ipv4/tcp_timestamps=1"
            echo
        fi

        # Check if SYNPROXY rules are too broad
        broad_rules=$(iptables -L INPUT -n | grep "SYNPROXY.*0.0.0.0/0.*0.0.0.0/0" | grep -v dport || true)
        if [[ -n "$broad_rules" ]]; then
            echo "WARNING: SYNPROXY rules without specific ports found"
            echo "  SYNPROXY works best when targeted at specific services"
            echo "  Consider adding --dport restrictions"
            echo
        fi

    else
        echo "SYNPROXY module: NOT LOADED"
        echo "To load: modprobe xt_SYNPROXY"
    fi
    echo

    # Conntrack diagnostics
    echo "=== CONNTRACK DIAGNOSTICS ==="
    if command -v conntrack >/dev/null 2>&1; then
        echo "conntrack command: AVAILABLE"
        current_conns=$(conntrack -L 2>/dev/null | wc -l)
        max_conns=$(cat /proc/net/nf_conntrack_max 2>/dev/null || echo "unknown")
        echo "Current connections: $current_conns"
        echo "Maximum connections: $max_conns"
        echo "Conntrack modules loaded:"
        lsmod | grep nf_conntrack | sed 's/^/  /'

        if [[ $current_conns -gt 0 ]]; then
            echo "Sample connections (last 3):"
            conntrack -L 2>/dev/null | tail -3 | sed 's/^/  /'
        else
            echo "No active connections tracked"
        fi
    else
        echo "conntrack command: NOT AVAILABLE"
        echo "Install with: apt install conntrack-tools"
    fi
    echo

    # Fallback chain check
    echo "=== FALLBACK CHAIN STATUS ==="
    if iptables -L "$FALLBACK_CHAIN" >/dev/null 2>&1; then
        echo "Fallback chain: EXISTS (permissive mode)"
        echo "Fallback chain rules:"
        iptables -L "$FALLBACK_CHAIN" -n -v | sed 's/^/  /'
    else
        echo "Fallback chain: NOT FOUND (restrictive mode)"
    fi
    echo

    # Port accessibility check
    echo "=== CRITICAL PORTS CHECK ==="
    critical_ports="22 80 443"
    for port in $critical_ports; do
        if ss -tlnp | grep -q ":$port "; then
            echo "Port $port: LISTENING"
            iptables_rule=$(iptables -L INPUT -n | grep ":$port\|dpt:$port" | head -1)
            if [[ -n "$iptables_rule" ]]; then
                echo "  Iptables rule: $iptables_rule"
            else
                echo "  Iptables rule: NONE - may be blocked by default policy"
            fi
        else
            echo "Port $port: NOT LISTENING"
        fi
    done
    echo

    # Recommendations
    echo "=== RECOMMENDATIONS ==="

    # Check for SSH rules
    if ! iptables -L INPUT -n | grep -q ":22\|dpt:22"; then
        echo "CRITICAL: No SSH rules found!"
        echo "  Add this to your base.rules before applying firewall:"
        echo "  -A INPUT -p tcp --dport 22 -j ACCEPT"
        echo
    fi

    # Check for invalid modular rules
    invalid_rules=$(find "$RULES_DIR" -name "*.rules" -type f -exec sh -c 'iptables-restore --test < "$1" >/dev/null 2>&1 || echo "$1"' _ {} \;)
    if [[ -n "$invalid_rules" ]]; then
        echo "ISSUE: Invalid rule files found:"
        echo "$invalid_rules" | sed 's/^/  /'
        echo "  Fix these files before applying firewall"
        echo
    fi

    # Check if Docker rules are needed but Docker isn't running
    if [[ -f "$RULES_DIR/10-docker.rules" ]] && ! systemctl is-active docker >/dev/null 2>&1; then
        echo "WARNING: Docker rules present but Docker not running"
        echo "  This may cause rule application to fail"
        echo "  Start Docker first: systemctl start docker"
        echo
    fi

    echo "=== DEBUG COMPLETE ==="
}

# Main function
main() {
    check_root
    check_iptables
    setup_directories

    case "${1:-start}" in
        start|apply)
            log "Starting firewall manager..."
            backup_rules
            apply_base_rules
            apply_modular_rules
            log "Firewall manager started successfully"
            ;;

        reload)
            log "Reloading firewall manager..."
            backup_rules
            apply_base_rules
            apply_modular_rules
            log "Firewall manager reloaded successfully"
            ;;

        stop|reset|cleanup)
            log "Stopping firewall manager..."
            cleanup_firewall
            log "Firewall manager stopped successfully"
            ;;

        harden)
            log "Hardening firewall (removing fallback chain)..."
            remove_fallback
            log "Firewall hardened successfully"
            ;;

        status)
            show_status
            ;;

        backup)
            backup_rules
            ;;

        restore)
            if [[ -z "${2:-}" ]]; then
                error_exit "Usage: $0 restore <backup_file>"
            fi
            restore_backup "$2"
            ;;

        debug)
            debug_firewall
            ;;

        *)
            echo "Usage: $0 {start|apply|stop|reset|cleanup|reload|harden|status|backup|restore|debug}"
            echo
            echo "Commands:"
            echo "  start   - Apply base rules and all modular rules"
            echo "  apply   - Alias for start"
            echo "  stop    - Reset firewall to permissive state (flush all rules)"
            echo "  reset   - Alias for stop"
            echo "  cleanup - Alias for stop"
            echo "  reload  - Reload all firewall rules"
            echo "  harden  - Remove fallback chain (enable restrictive mode)"
            echo "  status  - Show current firewall status"
            echo "  backup  - Backup current rules"
            echo "  restore - Restore from backup file"
            echo "  debug   - Comprehensive diagnostics (SYNPROXY, conntrack, rules)"
            exit 1
            ;;
    esac
}

# Execute main function
main "$@"
